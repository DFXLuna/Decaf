# Decaf Compiler Frontend
This project was the final project for a compilers course at the University of Wyoming.

## How It Works

* The program is broken into four pieces: the driver, the parser, the semantic analyzer, and the typechecker.

* The driver, found in program6.cpp, is in charge of starting the finite state automata generated by Bison, spawning the typechecker and 
then calling the necessary commands for type checking on the resulting tree.

* A parser is generated by Flex++ using the definitions found in the program6.lpp file. 
This file matches a set of instructions to a regex pattern.
Typically, a value is sent to Bison, the semantic analyzer.

* A finite state automaton is generated using the formal grammar definitions found in program6.y . 
The automaton receives a stream of values from the parser and matches them to the productions.
After being matched, a set of instructions corresponding to the production will generate a node for the input's 
syntax tree.

* The syntax tree structure is defined in node.h and node.cpp. Each node is responsible for typechecking itself using the 
typechecker generated in the driver.

* The typechecker is defined in tables.h and tables.cpp. It contains a tree structure of tables that keep track of valid types, method declarations 
and type instantiations. It can be queried to determine the existence of types and well as retrieving definitions for methods and types.
